from fastapi import FastAPI, HTTPException, UploadFile, File, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from shapely.geometry import Polygon, Point, LineString, MultiLineString, shape
from shapely.ops import transform
import shapefile  # pyshp
import uvicorn
import numpy as np
import pyproj
import os
import tempfile
import shutil
from pathlib import Path
from datetime import datetime
from typing import Optional, List

# Import GIS module
from gis import (
    import_boundary,
    validate_boundary,
    get_largest_polygon,
    project_to_utm,
    reproject_geometry,
    get_supported_formats,
    get_format_info,
)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- DATA MODELS ---
class PathRequest(BaseModel):
    points: list[list[float]]  # Expects [[x,y], [x,y], ...]
    width: float = 4.0          # Width of the path in meters

# --- GLOBAL STATE ---
current_field = None
current_walls = None
current_crs = None  # Track the CRS of the current field

# --- HELPER FUNCTIONS ---
# NOTE: Most helper functions moved to dedicated modules
# - flatten_geometry, carve_path → geometry/operations.py
# - export functions → export/shapefile.py
# - maze generation → mazification/generators.py

def flatten_geometry(geom):
    """Recursively flatten MultiLineString/GeometryCollection to list of line segments."""
    lines = []
    if geom is None or geom.is_empty:
        return lines
    if geom.geom_type == 'LineString':
        lines.append(list(geom.coords))
    elif geom.geom_type in ['MultiLineString', 'GeometryCollection']:
        for part in geom.geoms:
            lines.extend(flatten_geometry(part))
    return lines

def get_downloads_folder():
    """Get OS-specific Downloads folder path."""
    home = Path.home()
    downloads = home / "Downloads"
    if downloads.exists():
        return downloads
    # Fallback to home directory
    return home

def create_wkt_prj_file(filepath):
    """Create .prj file with EPSG:3857 WKT definition."""
    prj_content = (
        'PROJCS["WGS 84 / Pseudo-Mercator",'
        'GEOGCS["WGS 84",'
        'DATUM["WGS_1984",'
        'SPHEROID["WGS 84",6378137,298.257223563]],'
        'PRIMEM["Greenwich",0],'
        'UNIT["degree",0.0174532925199433]],'
        'PROJECTION["Mercator_1SP"],'
        'PARAMETER["central_meridian",0],'
        'PARAMETER["scale_factor",1],'
        'PARAMETER["false_easting",0],'
        'PARAMETER["false_northing",0],'
        'UNIT["metre",1]]'
    )
    with open(filepath, 'w') as f:
        f.write(prj_content)

# --- ENDPOINTS ---

@app.get("/")
def read_root():
    return {"status": "Corn Maze CAD Backend Running"}

@app.get("/health")
def health_check():
    """Health check endpoint for Electron to verify backend is running."""
    return {"status": "ok"}

@app.get("/import-gps-data")
def import_gps_data(demo: bool = Query(False, description="Load demo Iowa field")):
    """
    Import GPS data (demo mode only).

    For real file imports, use POST /import-boundary instead.
    """
    global current_field, current_walls, current_crs

    if not demo:
        raise HTTPException(
            status_code=400,
            detail={
                "error": "Use POST /import-boundary to import files",
                "error_code": "USE_IMPORT_BOUNDARY"
            }
        )

    # Mock GPS coordinates (Iowa cornfield - WGS84)
    gps_coords = [
        (-93.645, 42.025),
        (-93.640, 42.025),
        (-93.640, 42.028),
        (-93.645, 42.028),
        (-93.645, 42.025)
    ]

    # Create polygon and project to UTM (auto-detect zone)
    gps_polygon = Polygon(gps_coords)
    projected, target_crs = project_to_utm(gps_polygon, "EPSG:4326")

    # Center at origin (subtract centroid)
    minx, miny, maxx, maxy = projected.bounds
    cx, cy = (minx + maxx) / 2, (miny + maxy) / 2
    current_field = transform(lambda x, y: (x - cx, y - cy), projected)
    current_crs = target_crs  # UTM zone (e.g., EPSG:32615 for Iowa)

    # Reset walls when field changes
    current_walls = None

    return {
        "exterior": list(current_field.exterior.coords),
        "interiors": []  # No holes for now
    }

@app.get("/supported-formats")
def get_supported_file_formats():
    """Get list of supported file formats for boundary import."""
    format_info = get_format_info()
    formats_list = []

    for fmt_key, info in format_info.items():
        formats_list.append({
            "format": fmt_key,
            "name": info['name'],
            "extensions": [f".{ext}" for ext in info['extensions']],
            "description": info['description']
        })

    return {"formats": formats_list}

@app.post("/import-boundary")
async def import_boundary_file(
    file: Optional[UploadFile] = File(None),
    files: Optional[List[UploadFile]] = File(None),
    lat_col: Optional[str] = Query("lat", description="Latitude column name for CSV"),
    lon_col: Optional[str] = Query("lon", description="Longitude column name for CSV")
):
    """
    Import a field boundary from uploaded GIS file(s).

    Supported formats: KML, KMZ, Shapefile, GeoJSON, CSV

    For shapefiles, upload all component files (.shp, .shx, .dbf, .prj) together.

    Returns the boundary geometry in UTM projection, centered at origin.
    """
    global current_field, current_walls, current_crs

    # Determine if single file or multiple files
    if file and not files:
        # Single file upload
        uploaded_files = [file]
    elif files and not file:
        # Multiple file upload (shapefile bundle)
        uploaded_files = files
    elif file and files:
        # Both provided - combine them
        uploaded_files = [file] + files
    else:
        raise HTTPException(
            status_code=400,
            detail={
                "error": "No file provided",
                "error_code": "NO_FILE"
            }
        )

    # Create temp directory for files
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()

        # Save all uploaded files
        saved_files = []
        for uploaded_file in uploaded_files:
            file_ext = Path(uploaded_file.filename).suffix.lower()
            filename = Path(uploaded_file.filename).name

            # Save to temp directory
            temp_path = os.path.join(temp_dir, filename)
            content = await uploaded_file.read()
            with open(temp_path, 'wb') as f:
                f.write(content)
            saved_files.append((temp_path, file_ext.lstrip('.')))

        # Determine primary file (for shapefile, it's the .shp)
        primary_file = None
        file_ext = None

        if len(saved_files) == 1:
            # Single file
            primary_file, file_ext = saved_files[0]
        else:
            # Multiple files - find .shp for shapefile
            for path, ext in saved_files:
                if ext == 'shp':
                    primary_file = path
                    file_ext = ext
                    break

            if not primary_file:
                raise HTTPException(
                    status_code=400,
                    detail={
                        "error": "Multiple files uploaded but no .shp file found",
                        "error_code": "NO_SHP_IN_BUNDLE"
                    }
                )

            # Validate shapefile bundle
            exts = {ext for _, ext in saved_files}
            required_exts = {'shp', 'shx', 'dbf'}
            missing = required_exts - exts

            if missing:
                raise HTTPException(
                    status_code=400,
                    detail={
                        "error": f"Incomplete shapefile: missing {', '.join('.' + e for e in missing)}",
                        "error_code": "INCOMPLETE_SHAPEFILE"
                    }
                )

        # Check if format is supported
        supported = get_supported_formats()
        if file_ext not in supported:
            raise HTTPException(
                status_code=400,
                detail={
                    "error": f"Unsupported file format: .{file_ext}",
                    "supported_formats": supported,
                    "error_code": "UNSUPPORTED_FORMAT"
                }
            )

        # Import the boundary
        try:
            if file_ext == 'csv':
                # Pass lat/lon column parameters for CSV
                from gis.importers import import_csv
                result = import_csv(primary_file, lat_col=lat_col, lon_col=lon_col)
            else:
                result = import_boundary(primary_file)

        except Exception as import_error:
            raise HTTPException(
                status_code=400,
                detail={
                    "error": str(import_error),
                    "error_code": "IMPORT_FAILED"
                }
            )

        # Convert GeoJSON geometry to Shapely
        geometry = shape(result['geometry'])
        source_crs = result['crs']

        # If MultiPolygon, get largest
        if geometry.geom_type == 'MultiPolygon':
            geometry = get_largest_polygon(geometry)

        # Validate boundary
        validation = validate_boundary(geometry)

        if not validation['is_valid']:
            # Return validation errors (still 200, let client decide how to handle)
            return {
                "success": False,
                "validation": validation,
                "error": "Boundary validation failed"
            }

        # Project to UTM (auto-detect zone)
        projected_geom, target_crs = project_to_utm(geometry, source_crs)

        # Center at origin
        minx, miny, maxx, maxy = projected_geom.bounds
        cx, cy = (minx + maxx) / 2, (miny + maxy) / 2
        current_field = transform(lambda x, y: (x - cx, y - cy), projected_geom)
        current_crs = target_crs

        # Reset walls when field changes
        current_walls = None

        # Calculate area in hectares (1 hectare = 10,000 m²)
        area_hectares = validation['area_m2'] / 10000.0

        # Return success
        return {
            "success": True,
            "geometry": {
                "exterior": list(current_field.exterior.coords),
                "interiors": [list(interior.coords) for interior in current_field.interiors]
            },
            "crs": target_crs,
            "source_crs": source_crs,
            "source_format": result['source_format'],
            "validation": validation,
            "bounds": list(current_field.bounds),  # [minx, miny, maxx, maxy]
            "area_hectares": round(area_hectares, 2),
            "warnings": validation.get('warnings', [])
        }

    finally:
        # Clean up temp directory and all files
        if temp_dir and os.path.exists(temp_dir):
            try:
                shutil.rmtree(temp_dir)
            except Exception:
                pass  # Ignore cleanup errors

@app.get("/generate-maze")
def generate_maze():
    """Generate 10m grid clipped to field boundary."""
    global current_field, current_walls

    if not current_field:
        raise HTTPException(
            status_code=400,
            detail={"error": "Import GPS data first", "error_code": "NO_FIELD"}
        )

    spacing = 10.0  # meters
    minx, miny, maxx, maxy = current_field.bounds

    # Create grid lines
    lines = []
    for x in np.arange(minx, maxx, spacing):
        lines.append(LineString([(x, miny), (x, maxy)]))
    for y in np.arange(miny, maxy, spacing):
        lines.append(LineString([(minx, y), (maxx, y)]))

    # Clip to field boundary
    current_walls = MultiLineString(lines).intersection(current_field)

    return {"walls": flatten_geometry(current_walls)}

@app.post("/carve-path")
def carve_path(req: PathRequest):
    """Carve a path through maze walls using boolean difference."""
    global current_walls

    if not current_walls:
        raise HTTPException(
            status_code=400,
            detail={"error": "Generate maze first", "error_code": "NO_MAZE"}
        )

    if len(req.points) < 2:
        raise HTTPException(
            status_code=400,
            detail={"error": "Path too short (need at least 2 points)", "error_code": "PATH_TOO_SHORT"}
        )

    try:
        # Create path LineString
        path_line = LineString(req.points)

        # Buffer to create eraser polygon
        eraser = path_line.buffer(req.width / 2.0, cap_style=1)  # Round caps

        # Check if path intersects field (warning, not error)
        if not eraser.intersects(current_field):
            # Path entirely outside - return unchanged
            return {
                "walls": flatten_geometry(current_walls),
                "warning": "Path outside field boundary"
            }

        # Boolean difference
        current_walls = current_walls.difference(eraser)

        return {"walls": flatten_geometry(current_walls)}

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"error": str(e), "error_code": "INVALID_GEOMETRY"}
        )

@app.get("/export-shapefile")
def export_shapefile():
    """Export current walls to Shapefile in Downloads folder."""
    global current_walls

    if not current_walls:
        raise HTTPException(
            status_code=400,
            detail={"error": "No maze to export", "error_code": "NO_MAZE"}
        )

    try:
        # Determine output path
        downloads = get_downloads_folder()
        base_name = "maze_walls"
        output_path = downloads / f"{base_name}.shp"

        # Avoid overwriting - add timestamp if exists
        if output_path.exists():
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            base_name = f"maze_walls_{timestamp}"
            output_path = downloads / f"{base_name}.shp"

        # Create shapefile writer
        with shapefile.Writer(str(output_path)) as writer:
            writer.field('ID', 'N')  # Numeric field

            # Write geometries
            flattened = flatten_geometry(current_walls)
            for i, line_coords in enumerate(flattened):
                writer.line([line_coords])
                writer.record(i)

        # Create .prj file
        prj_path = output_path.with_suffix('.prj')
        create_wkt_prj_file(str(prj_path))

        return {
            "success": True,
            "path": str(output_path),
            "files": [
                str(output_path),
                str(output_path.with_suffix('.shx')),
                str(output_path.with_suffix('.dbf')),
                str(prj_path)
            ]
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"error": str(e), "error_code": "EXPORT_FAILED"}
        )

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000)
